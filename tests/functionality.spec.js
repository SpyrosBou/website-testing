/**
 * Functionality Testing Suite - Generated from YAML Specifications
 * 
 * This file is automatically generated from YAML test specifications.
 * It provides comprehensive functionality testing for WordPress sites
 * following industry standards and best practices.
 * 
 * Features:
 * - Page availability and response validation
 * - Internal link checking with rate limiting
 * - JavaScript error detection and interactive testing
 * - Form validation and accessibility testing
 * - WCAG 2.1 AA compliance testing using @axe-core/playwright
 * - WordPress-specific plugin and theme testing
 * 
 * Generated at: 2025-08-15T19:42:00.000Z
 */

const { test, expect } = require('@playwright/test');
const { AxeBuilder } = require('@axe-core/playwright');
const SiteLoader = require('../utils/site-loader');
const { 
  setupTestPage, 
  teardownTestPage, 
  safeNavigate, 
  waitForPageStability, 
  safeElementInteraction,
  retryOperation,
  ErrorContext 
} = require('../utils/test-helpers');
const { TestDataFactory, createTestData } = require('../utils/test-data-factory');
const { WordPressPageObjects } = require('../utils/wordpress-page-objects');

test.describe("Functionality Testing Suite", () => {
  let siteConfig;
  let errorContext;
  let wpPageObjects;

  test.beforeEach(async ({ page, context }) => {
    const siteName = process.env.SITE_NAME;
    if (!siteName) {
      throw new Error("SITE_NAME environment variable is required");
    }

    siteConfig = SiteLoader.loadSite(siteName);
    SiteLoader.validateSiteConfig(siteConfig);

    errorContext = await setupTestPage(page, context);
    wpPageObjects = new WordPressPageObjects(page, siteConfig);
  });

  test.afterEach(async ({ page, context }) => {
    await teardownTestPage(page, context, errorContext);
  });

  test.describe("Core Infrastructure", () => {
    test.describe("Page Availability", () => {
      test("Verify all configured pages load successfully or handle errors gracefully", async ({ page }) => {
        test.setTimeout(30000);

        errorContext.setTest('Page Availability Check');
        
        for (const testPage of siteConfig.testPages) {
          await test.step(`Checking page availability: ${testPage}`, async () => {
            errorContext.setPage(testPage);
            errorContext.setAction('navigating to page');
            
            try {
              // Use page objects for navigation with enhanced error handling
              const response = await wpPageObjects.navigate(`${siteConfig.baseUrl}${testPage}`);
              
              // Check for 404 using semantic detection
              const is404 = await wpPageObjects.is404Page();
              if (is404) {
                console.log(`⚠️  Page not found: ${testPage} - detected using semantic 404 checking`);
                await test.step(`Page not found: ${testPage}`, async () => {
                  // Attach page status for Allure reporting
                  await page.screenshot({ path: `test-results/404-${testPage.replace(/\//g, '-')}.png` });
                });
                return; // Skip this page
              }
              
              if (response.status() >= 500) {
                throw new Error(`Server error on ${testPage}: ${response.status()}`);
              }
              
              if (response.status() >= 400) {
                console.log(`⚠️  Client error on ${testPage}: ${response.status()}`);
              }
              
              // For successful responses, verify WordPress page structure using page objects
              if (response.status() >= 200 && response.status() < 300) {
                // Use page objects for comprehensive structure verification
                const elements = await wpPageObjects.verifyCriticalElements();
                
                console.log(`✅ Page structure check for ${testPage}:`, {
                  header: elements.header ? '✅' : '⚠️',
                  navigation: elements.navigation ? '✅' : '⚠️', 
                  content: elements.content ? '✅' : '⚠️',
                  footer: elements.footer ? '✅' : '⚠️'
                });
                
                // Verify page has title using semantic method
                const title = await wpPageObjects.getTitle();
                expect(title).toBeTruthy();
              }
              
            } catch (error) {
              errorContext.logError(error, { page: testPage, status: 'navigation_failed' });
              throw error;
            }
          });
        }
      });
    });

    test.describe("Response Validation", () => {
      test("Validate HTTP responses and content integrity", async ({ page }) => {
        test.setTimeout(20000);

        errorContext.setTest('HTTP Response Validation');
        
        for (const testPage of siteConfig.testPages) {
          await test.step(`Validating response for: ${testPage}`, async () => {
            errorContext.setPage(testPage);
            
            const response = await safeNavigate(page, `${siteConfig.baseUrl}${testPage}`);
            
            // Check response status
            expect([200, 301, 302, 404]).toContain(response.status());
            
            if (response.status() === 200) {
              // Validate content type
              const contentType = response.headers()['content-type'];
              expect(contentType).toContain('text/html');
              
              // Validate basic HTML structure
              await expect(page.locator('html[lang]')).toBeAttached();
              await expect(page.locator('meta[charset], meta[http-equiv="Content-Type"]')).toBeAttached();
              await expect(page.locator('meta[name="viewport"]')).toBeAttached();
              
              // Check for WordPress debug information exposure
              const bodyText = await page.locator('body').textContent();
              expect(bodyText).not.toContain('Fatal error');
              expect(bodyText).not.toContain('Warning:');
              expect(bodyText).not.toContain('Notice:');
              
              console.log(`✅ Response validation passed for ${testPage}`);
            }
          });
        }
      });
    });

    test.describe("Performance Monitoring", () => {
      test("Measure and validate page load performance metrics", async ({ page }) => {
        test.setTimeout(45000);

        errorContext.setTest('Performance Monitoring');
        
        const performanceData = [];
        
        for (const testPage of siteConfig.testPages.slice(0, 5)) { // Limit for performance
          await test.step(`Measuring performance for: ${testPage}`, async () => {
            errorContext.setPage(testPage);
            
            const startTime = Date.now();
            const response = await safeNavigate(page, `${siteConfig.baseUrl}${testPage}`);
            
            if (response.status() !== 200) {
              console.log(`⚠️  Skipping performance test for ${testPage} (status: ${response.status()})`);
              return;
            }
            
            await waitForPageStability(page, { timeout: 10000 });
            
            const loadTime = Date.now() - startTime;
            
            // Get performance metrics from browser
            const metrics = await page.evaluate(() => {
              const navigation = performance.getEntriesByType('navigation')[0];
              return {
                domContentLoaded: navigation.domContentLoadedEventEnd - navigation.navigationStart,
                loadComplete: navigation.loadEventEnd - navigation.navigationStart,
                firstPaint: performance.getEntriesByType('paint').find(p => p.name === 'first-paint')?.startTime || 0,
              };
            });
            
            performanceData.push({
              page: testPage,
              loadTime,
              ...metrics
            });
            
            // Check against thresholds (warn, don't fail)
            if (loadTime > 3000) {
              console.log(`⚠️  Page ${testPage} took ${loadTime}ms to load (>3s threshold)`);
            } else {
              console.log(`✅ Page ${testPage} loaded in ${loadTime}ms`);
            }
          });
        }
        
        // Report performance summary
        if (performanceData.length > 0) {
          const avgLoadTime = performanceData.reduce((sum, data) => sum + data.loadTime, 0) / performanceData.length;
          console.log(`📊 Average load time: ${Math.round(avgLoadTime)}ms`);
        }
      });
    });
  });

  test.describe("Navigation & UX", () => {
    test.describe("Internal Links", () => {
      test("Validate all internal links are functional and accessible", async ({ page }) => {
        test.setTimeout(30000);

        errorContext.setTest('Internal Links Validation');
        
        const brokenLinks = [];
        const checkedLinks = new Set();
        
        for (const testPage of siteConfig.testPages) {
          await test.step(`Checking internal links on: ${testPage}`, async () => {
            errorContext.setPage(testPage);
            
            const response = await safeNavigate(page, `${siteConfig.baseUrl}${testPage}`);
            if (response.status() !== 200) {
              console.log(`⚠️  Skipping link check for ${testPage} (status: ${response.status()})`);
              return;
            }
            
            await waitForPageStability(page);
            
            // Extract internal links
            const links = await page.locator('a[href^="/"], a[href^="' + siteConfig.baseUrl + '"]').all();
            console.log(`Found ${links.length} internal links on ${testPage}`);
            
            // Check links (with rate limiting)
            let linkCount = 0;
            for (const link of links.slice(0, 20)) { // Limit for performance
              linkCount++;
              if (linkCount > 1 && linkCount % 5 === 0) {
                await page.waitForTimeout(500); // Rate limiting
              }
              
              try {
                const href = await link.getAttribute('href');
                if (!href || checkedLinks.has(href)) continue;
                
                checkedLinks.add(href);
                const fullUrl = href.startsWith('/') ? `${siteConfig.baseUrl}${href}` : href;
                
                const linkResponse = await page.request.head(fullUrl);
                if (linkResponse.status() >= 400) {
                  brokenLinks.push({ url: fullUrl, status: linkResponse.status(), page: testPage });
                }
              } catch (error) {
                console.log(`⚠️  Could not check link: ${error.message}`);
              }
            }
          });
        }
        
        // Report results
        if (brokenLinks.length > 0) {
          const report = brokenLinks.map(link => 
            `${link.url} (Status: ${link.status}) on page ${link.page}`
          ).join('\n');
          
          console.error(`❌ Found ${brokenLinks.length} broken links:\n${report}`);
          expect.soft(brokenLinks.length).toBe(0);
        } else {
          console.log('✅ All internal links are functional');
        }
      });
    });

    test.describe("Critical Elements", () => {
      test("Validate elements that should be present across all pages", async ({ page }) => {
        test.setTimeout(20000);

        errorContext.setTest('Critical Elements Check');
        
        for (const testPage of siteConfig.testPages) {
          await test.step(`Checking critical elements: ${testPage}`, async () => {
            errorContext.setPage(testPage);
            
            const response = await safeNavigate(page, `${siteConfig.baseUrl}${testPage}`);
            if (response.status() !== 200) {
              console.log(`⚠️  Skipping critical elements test for ${testPage} (status: ${response.status()})`);
              return;
            }
            
            await waitForPageStability(page);
            
            // Check for header
            const headerSelectors = ['header', '.header', '.site-header'];
            let headerFound = false;
            for (const selector of headerSelectors) {
              if (await page.locator(selector).isVisible()) {
                headerFound = true;
                break;
              }
            }
            expect.soft(headerFound, `Header element should be present on ${testPage}`).toBe(true);
            
            // Check for navigation
            const navSelectors = ['nav', '.main-navigation', '.primary-menu', '#main-menu'];
            let navFound = false;
            for (const selector of navSelectors) {
              if (await page.locator(selector).isVisible()) {
                navFound = true;
                break;
              }
            }
            expect.soft(navFound, `Navigation element should be present on ${testPage}`).toBe(true);
            
            // Check for footer
            const footerSelectors = ['footer', '.footer', '.site-footer'];
            let footerFound = false;
            for (const selector of footerSelectors) {
              if (await page.locator(selector).isVisible()) {
                footerFound = true;
                break;
              }
            }
            expect.soft(footerFound, `Footer element should be present on ${testPage}`).toBe(true);
            
            // Check for main content
            const mainSelectors = ['main', '.main', '.content', '#content'];
            let mainFound = false;
            for (const selector of mainSelectors) {
              if (await page.locator(selector).isVisible()) {
                mainFound = true;
                break;
              }
            }
            expect.soft(mainFound, `Main content area should be present on ${testPage}`).toBe(true);
            
            console.log(`✅ Critical elements check completed for ${testPage}`);
          });
        }
      });
    });
  });

  test.describe("Interactive Elements", () => {
    test.describe("JavaScript Error Detection", () => {
      test("Monitor and detect JavaScript errors during page interactions", async ({ page }) => {
        test.setTimeout(30000);

        errorContext.setTest('JavaScript Error Detection');
        
        const consoleErrors = [];
        const ignoredPatterns = ['analytics', 'google-analytics', 'gtag', 'facebook', 'twitter'];
        
        // Set up console monitoring
        page.on('console', msg => {
          if (msg.type() === 'error') {
            const text = msg.text();
            const shouldIgnore = ignoredPatterns.some(pattern => text.toLowerCase().includes(pattern));
            if (!shouldIgnore) {
              consoleErrors.push({ message: text, url: page.url() });
            }
          }
        });
        
        page.on('pageerror', error => {
          const shouldIgnore = ignoredPatterns.some(pattern => error.message.toLowerCase().includes(pattern));
          if (!shouldIgnore) {
            consoleErrors.push({ message: error.message, url: page.url(), stack: error.stack });
          }
        });
        
        for (const testPage of siteConfig.testPages) {
          await test.step(`Testing JavaScript on: ${testPage}`, async () => {
            errorContext.setPage(testPage);
            
            const response = await safeNavigate(page, `${siteConfig.baseUrl}${testPage}`);
            if (response.status() !== 200) {
              console.log(`⚠️  Skipping JS test for ${testPage} (status: ${response.status()})`);
              return;
            }
            
            await waitForPageStability(page);
            
            // Test interactive elements using semantic queries
            const interactiveRoles = ['button', 'link', 'tab', 'menuitem'];
            
            for (const role of interactiveRoles) {
              const elements = await page.getByRole(role).all();
              console.log(`Found ${elements.length} ${role} elements`);
              
              // Test up to 8 elements of each type
              for (let i = 0; i < Math.min(elements.length, 8); i++) {
                try {
                  await safeElementInteraction(elements[i], 'click', { timeout: 3000 });
                  await page.waitForTimeout(100); // Brief pause between interactions
                } catch (error) {
                  console.log(`⚠️  Could not interact with ${role} element ${i + 1}: ${error.message}`);
                }
              }
            }
          });
        }
        
        // Report JavaScript errors
        if (consoleErrors.length > 0) {
          const errorReport = consoleErrors.map(error => 
            `Page: ${error.url}\nError: ${error.message}${error.stack ? '\nStack: ' + error.stack.substring(0, 200) + '...' : ''}`
          ).join('\n\n');
          
          console.error(`❌ Found ${consoleErrors.length} JavaScript errors`);
          expect.soft(consoleErrors.length).toBe(0);
        } else {
          console.log('✅ No critical JavaScript errors detected');
        }
      });
    });

    test.describe("Form Testing", () => {
      test("Test form interactions and validation using test data", async ({ page }) => {
        test.setTimeout(30000);

        errorContext.setTest('Form Testing');
        
        if (!siteConfig.forms || siteConfig.forms.length === 0) {
          console.log('ℹ️  No forms configured for testing');
          return;
        }
        
        const testData = createTestData('contact');
        
        for (const formConfig of siteConfig.forms) {
          await test.step(`Testing form: ${formConfig.name}`, async () => {
            const formPage = formConfig.page || '/contact';
            errorContext.setPage(formPage);
            
            // Use page objects for navigation with built-in 404 detection
            const response = await wpPageObjects.navigate(`${siteConfig.baseUrl}${formPage}`);
            if (response.status() !== 200) {
              console.log(`⚠️  Skipping form test for ${formPage} (status: ${response.status()})`);
              return;
            }
            
            // Create form instance using page objects
            const formInstance = wpPageObjects.createForm(formConfig);
            
            try {
              // Fill form using semantic approach with intelligent fallbacks
              await formInstance.fillForm({
                name: testData.formData.name,
                email: testData.formData.email,
                message: testData.formData.message
              });
              
              console.log(`✅ Form ${formConfig.name} fields filled successfully using semantic queries`);
              
              // Test form validation by checking empty form submission
              await test.step('Testing form validation', async () => {
                const validationWorking = await formInstance.testValidation();
                if (validationWorking) {
                  console.log('✅ Form validation is working correctly');
                } else {
                  console.log('⚠️  Form validation may not be working as expected');
                }
              });
              
            } catch (error) {
              console.log(`⚠️  Form testing failed for ${formConfig.name}: ${error.message}`);
              // Continue with other forms
            }
          });
        }
      });
    });
  });

  test.describe("Accessibility", () => {
    test.describe("WCAG Compliance", () => {
      test("Run automated accessibility scans using axe-core", async ({ page }) => {
        test.setTimeout(45000);

        errorContext.setTest('Accessibility Testing');
        
        for (const testPage of siteConfig.testPages) {
          await test.step(`Accessibility scan: ${testPage}`, async () => {
            errorContext.setPage(testPage);
            
            const response = await safeNavigate(page, `${siteConfig.baseUrl}${testPage}`);
            if (response.status() !== 200) {
              console.log(`⚠️  Skipping accessibility test for ${testPage} (status: ${response.status()})`);
              return;
            }
            
            await waitForPageStability(page);
            
            try {
              const accessibilityScanResults = await new AxeBuilder({ page })
                .withTags(['wcag2a', 'wcag2aa', 'wcag21aa'])
                .analyze();
              
              const criticalViolations = accessibilityScanResults.violations.filter(
                violation => violation.impact === 'critical' || violation.impact === 'serious'
              );
              
              if (criticalViolations.length > 0) {
                const violationReport = criticalViolations.map(violation => 
                  `${violation.id}: ${violation.description}\nImpact: ${violation.impact}\nHelp: ${violation.helpUrl}\nNodes: ${violation.nodes.length}`
                ).join('\n\n');
                
                console.error(`❌ ${criticalViolations.length} critical accessibility violations on ${testPage}`);
                expect.soft(criticalViolations.length).toBe(0);
              } else {
                console.log(`✅ No critical accessibility violations on ${testPage}`);
              }
              
              // Log moderate violations as warnings
              const moderateViolations = accessibilityScanResults.violations.filter(
                violation => violation.impact === 'moderate'
              );
              
              if (moderateViolations.length > 0) {
                console.log(`⚠️  ${moderateViolations.length} moderate accessibility issues on ${testPage}`);
              }
              
            } catch (error) {
              console.error(`⚠️  Accessibility scan failed for ${testPage}: ${error.message}`);
            }
          });
        }
      });
    });
  });

  test.describe("WordPress Specific", () => {
    test.describe("Plugin Compatibility", () => {
      test("Test contact form plugin functionality and compatibility", async ({ page }) => {
        test.setTimeout(30000);

        errorContext.setTest('WordPress Plugin Testing');
        
        const detectedPlugins = [];
        
        for (const testPage of siteConfig.testPages.slice(0, 3)) { // Sample pages
          await test.step(`Detecting plugins on: ${testPage}`, async () => {
            const response = await safeNavigate(page, `${siteConfig.baseUrl}${testPage}`);
            if (response.status() !== 200) return;
            
            await waitForPageStability(page);
            
            // Detect Contact Form 7
            if (await page.locator('.wpcf7-form, .wpcf7').isVisible()) {
              detectedPlugins.push('Contact Form 7');
              console.log('✅ Contact Form 7 detected');
            }
            
            // Detect Gravity Forms
            if (await page.locator('.gform_wrapper').isVisible()) {
              detectedPlugins.push('Gravity Forms');
              console.log('✅ Gravity Forms detected');
            }
            
            // Detect WPForms
            if (await page.locator('.wpforms-form').isVisible()) {
              detectedPlugins.push('WPForms');
              console.log('✅ WPForms detected');
            }
            
            // Detect Yoast SEO
            const yoastMeta = await page.locator('meta[name="generator"][content*="Yoast"]').isVisible();
            if (yoastMeta) {
              detectedPlugins.push('Yoast SEO');
              console.log('✅ Yoast SEO detected');
            }
          });
        }
        
        if (detectedPlugins.length > 0) {
          console.log(`📊 Detected plugins: ${detectedPlugins.join(', ')}`);
        } else {
          console.log('ℹ️  No common plugins detected');
        }
      });
    });

    test.describe("Theme Elements", () => {
      test("Detect active theme and analyze its structure", async ({ page }) => {
        test.setTimeout(25000);

        errorContext.setTest('WordPress Theme Testing');
        
        await test.step('Analyzing theme structure', async () => {
          const response = await safeNavigate(page, siteConfig.baseUrl);
          if (response.status() !== 200) return;
          
          await waitForPageStability(page);
          
          // Detect theme type
          const isBlockTheme = await page.locator('.wp-site-blocks, .is-layout-').isVisible();
          const hasClassicElements = await page.locator('.widget, .sidebar').isVisible();
          
          if (isBlockTheme) {
            console.log('✅ Block theme detected');
            
            // Test block theme elements
            const blockElements = await page.locator('[class*="wp-block-"]').count();
            console.log(`📊 Found ${blockElements} block elements`);
          } else if (hasClassicElements) {
            console.log('✅ Classic theme detected');
            
            // Test classic theme elements
            const widgets = await page.locator('.widget').count();
            console.log(`📊 Found ${widgets} widgets`);
          } else {
            console.log('ℹ️  Theme type could not be determined');
          }
          
          // Check responsive elements
          const mobileMenuExists = await page.locator('.mobile-menu, .hamburger, .menu-toggle').isVisible();
          if (mobileMenuExists) {
            console.log('✅ Mobile navigation detected');
          }
          
          console.log('✅ Theme analysis completed');
        });
      });
    });
  });
});