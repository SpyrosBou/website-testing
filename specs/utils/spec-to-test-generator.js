/**
 * Specification to Test Generator for WordPress Testing Suite
 * 
 * Converts YAML specifications into executable Playwright test code,
 * integrating with existing utilities and following industry best practices.
 */

const SpecificationLoader = require('./spec-loader');

class SpecificationToTestGenerator {
  constructor() {
    this.specLoader = new SpecificationLoader();
    this.indentLevel = 0;
    this.indentSize = 2;
  }

  /**
   * Generate complete functionality test file from specifications
   * @param {Object} options - Generation options
   * @returns {string} Generated test file content
   */
  generateFunctionalityTest(options = {}) {
    const { includeCategories = null, browsers = ['chrome', 'firefox', 'safari'] } = options;
    
    const allSpecs = this.specLoader.loadAllSpecifications();
    const testCode = [];

    // Generate file header
    testCode.push(this.generateTestHeader());
    testCode.push('');

    // Generate imports
    testCode.push(this.generateImports());
    testCode.push('');

    // Generate main test describe block
    testCode.push('test.describe("Functionality Testing Suite", () => {');
    this.indentLevel++;

    // Generate test setup
    testCode.push(this.indent('let siteConfig;'));
    testCode.push(this.indent('let errorContext;'));
    testCode.push('');

    testCode.push(this.indent('test.beforeEach(async ({ page, context, errorContext: sharedErrorContext }, testInfo) => {'));
    this.indentLevel++;
    testCode.push(this.indent('const siteName = process.env.SITE_NAME;'));
    testCode.push(this.indent('if (!siteName) {'));
    testCode.push(this.indent('  throw new Error("SITE_NAME environment variable is required");'));
    testCode.push(this.indent('}'));
    testCode.push('');
    testCode.push(this.indent('siteConfig = SiteLoader.loadSite(siteName);'));
    testCode.push(this.indent('SiteLoader.validateSiteConfig(siteConfig);'));
    testCode.push('');
    testCode.push(this.indent('errorContext = sharedErrorContext;'));
    this.indentLevel--;
    testCode.push(this.indent('});'));
    testCode.push('');

    // Generate test categories
    for (const [category, specs] of Object.entries(allSpecs)) {
      if (includeCategories && !includeCategories.includes(category)) continue;
      
      testCode.push(this.generateCategoryTests(category, specs));
      testCode.push('');
    }

    this.indentLevel--;
    testCode.push('});');

    return testCode.join('\n');
  }

  /**
   * Generate test header with documentation
   */
  generateTestHeader() {
    return `/**
 * Functionality Testing Suite - Generated from YAML Specifications
 * 
 * This file is automatically generated from YAML test specifications.
 * It provides comprehensive functionality testing for WordPress sites
 * following industry standards and best practices.
 * 
 * Features:
 * - Page availability and response validation
 * - Internal link checking with rate limiting
 * - JavaScript error detection and interactive testing
 * - Form validation and accessibility testing
 * - WCAG 2.1 AA compliance testing using @axe-core/playwright
 * - WordPress-specific plugin and theme testing
 * 
 * Generated at: ${new Date().toISOString()}
 */`;
  }

  /**
   * Generate import statements
   */
  generateImports() {
    return `const { test, expect } = require('../utils/test-fixtures');
const { AxeBuilder } = require('@axe-core/playwright');
const SiteLoader = require('../utils/site-loader');
const { 
  safeNavigate, 
  waitForPageStability, 
  safeElementInteraction,
  retryOperation 
} = require('../utils/test-helpers');
const { TestDataFactory, createTestData } = require('../utils/test-data-factory');
const { WordPressPageObjects } = require('../utils/wordpress-page-objects');`;
  }

  /**
   * Generate tests for a specific category
   */
  generateCategoryTests(category, specs) {
    const categoryTitle = this.formatCategoryTitle(category);
    const testCode = [];

    testCode.push(this.indent(`test.describe("${categoryTitle}", () => {`));
    this.indentLevel++;

    for (const [specName, spec] of Object.entries(specs)) {
      if (!spec.test_cases || spec.test_cases.length === 0) continue;
      
      testCode.push(this.generateSpecificationTests(specName, spec));
      testCode.push('');
    }

    this.indentLevel--;
    testCode.push(this.indent('});'));

    return testCode.join('\n');
  }

  /**
   * Generate tests for a specific specification
   */
  generateSpecificationTests(specName, spec) {
    const specTitle = this.formatSpecTitle(specName);
    const testCode = [];

    testCode.push(this.indent(`test.describe("${specTitle}", () => {`));
    this.indentLevel++;

    for (const testCase of spec.test_cases) {
      testCode.push(this.generateTestCase(testCase, spec));
      testCode.push('');
    }

    this.indentLevel--;
    testCode.push(this.indent('});'));

    return testCode.join('\n');
  }

  /**
   * Generate individual test case
   */
  generateTestCase(testCase, spec) {
    const testCode = [];
    const timeout = testCase.timeout || spec.configuration?.timeout || 30000;
    
    testCode.push(this.indent(`test("${testCase.description}", async ({ page }) => {`));
    this.indentLevel++;

    // Set test timeout
    testCode.push(this.indent(`test.setTimeout(${timeout});`));
    testCode.push('');

    // Generate test body based on test case type
    if (testCase.name.includes('page_availability')) {
      testCode.push(this.generatePageAvailabilityTest());
    } else if (testCase.name.includes('internal_link')) {
      testCode.push(this.generateInternalLinksTest());
    } else if (testCase.name.includes('javascript_error')) {
      testCode.push(this.generateJavaScriptErrorTest());
    } else if (testCase.name.includes('form')) {
      testCode.push(this.generateFormTest());
    } else if (testCase.name.includes('accessibility')) {
      testCode.push(this.generateAccessibilityTest());
    } else if (testCase.name.includes('critical_elements')) {
      testCode.push(this.generateCriticalElementsTest());
    } else {
      testCode.push(this.generateGenericTest(testCase));
    }

    this.indentLevel--;
    testCode.push(this.indent('});'));

    return testCode.join('\n');
  }

  /**
   * Generate page availability test
   */
  generatePageAvailabilityTest() {
    return this.indent(`
    errorContext.setTest('Page Availability Check');
    
    for (const testPage of siteConfig.testPages) {
      await test.step(\`Checking page availability: \${testPage}\`, async () => {
        errorContext.setPage(testPage);
        errorContext.setAction('navigating to page');
        
        try {
          const response = await safeNavigate(page, \`\${siteConfig.baseUrl}\${testPage}\`);
          
          if (response.status() === 404) {
            console.log(\`⚠️  Page not found: \${testPage} - skipping further tests\`);
            return; // Skip this page
          }
          
          if (response.status() >= 500) {
            throw new Error(\`Server error on \${testPage}: \${response.status()}\`);
          }
          
          if (response.status() >= 400) {
            console.log(\`⚠️  Client error on \${testPage}: \${response.status()}\`);
          }
          
          // For successful responses, verify basic page structure
          if (response.status() >= 200 && response.status() < 300) {
            await expect(page.locator('html')).toBeVisible();
            await expect(page.locator('head')).toBeAttached();
            await expect(page.locator('body')).toBeVisible();
            
            const title = await page.title();
            expect(title).toBeTruthy();
          }
          
        } catch (error) {
          errorContext.logError(error, { page: testPage, status: 'navigation_failed' });
          throw error;
        }
      });
    }`);
  }

  /**
   * Generate internal links test
   */
  generateInternalLinksTest() {
    return this.indent(`
    errorContext.setTest('Internal Links Validation');
    
    const brokenLinks = [];
    const checkedLinks = new Set();
    
    for (const testPage of siteConfig.testPages) {
      await test.step(\`Checking internal links on: \${testPage}\`, async () => {
        errorContext.setPage(testPage);
        
        const response = await safeNavigate(page, \`\${siteConfig.baseUrl}\${testPage}\`);
        if (response.status() !== 200) {
          console.log(\`⚠️  Skipping link check for \${testPage} (status: \${response.status()})\`);
          return;
        }
        
        await waitForPageStability(page);
        
        // Extract internal links
        const links = await page.locator('a[href^="/"], a[href^="' + siteConfig.baseUrl + '"]').all();
        console.log(\`Found \${links.length} internal links on \${testPage}\`);
        
        // Check links (with rate limiting)
        let linkCount = 0;
        for (const link of links.slice(0, 20)) { // Limit for performance
          linkCount++;
          if (linkCount > 1 && linkCount % 5 === 0) {
            await page.waitForTimeout(500); // Rate limiting
          }
          
          try {
            const href = await link.getAttribute('href');
            if (!href || checkedLinks.has(href)) continue;
            
            checkedLinks.add(href);
            const fullUrl = href.startsWith('/') ? \`\${siteConfig.baseUrl}\${href}\` : href;
            
            const linkResponse = await page.request.head(fullUrl);
            if (linkResponse.status() >= 400) {
              brokenLinks.push({ url: fullUrl, status: linkResponse.status(), page: testPage });
            }
          } catch (error) {
            console.log(\`⚠️  Could not check link: \${error.message}\`);
          }
        }
      });
    }
    
    // Report results
    if (brokenLinks.length > 0) {
      const report = brokenLinks.map(link => 
        \`\${link.url} (Status: \${link.status}) on page \${link.page}\`
      ).join('\\n');
      
      // Use soft assertion to continue testing
      console.error(\`❌ Found \${brokenLinks.length} broken links:\\n\${report}\`);
      expect.soft(brokenLinks.length).toBe(0);
    } else {
      console.log('✅ All internal links are functional');
    }`);
  }

  /**
   * Generate JavaScript error test
   */
  generateJavaScriptErrorTest() {
    return this.indent(`
    errorContext.setTest('JavaScript Error Detection');
    
    const consoleErrors = [];
    const ignoredPatterns = ['analytics', 'google-analytics', 'gtag', 'facebook', 'twitter'];
    
    // Set up console monitoring
    page.on('console', msg => {
      if (msg.type() === 'error') {
        const text = msg.text();
        const shouldIgnore = ignoredPatterns.some(pattern => text.toLowerCase().includes(pattern));
        if (!shouldIgnore) {
          consoleErrors.push({ message: text, url: page.url() });
        }
      }
    });
    
    page.on('pageerror', error => {
      const shouldIgnore = ignoredPatterns.some(pattern => error.message.toLowerCase().includes(pattern));
      if (!shouldIgnore) {
        consoleErrors.push({ message: error.message, url: page.url(), stack: error.stack });
      }
    });
    
    for (const testPage of siteConfig.testPages) {
      await test.step(\`Testing JavaScript on: \${testPage}\`, async () => {
        errorContext.setPage(testPage);
        
        const response = await safeNavigate(page, \`\${siteConfig.baseUrl}\${testPage}\`);
        if (response.status() !== 200) {
          console.log(\`⚠️  Skipping JS test for \${testPage} (status: \${response.status()})\`);
          return;
        }
        
        await waitForPageStability(page);
        
        // Test interactive elements using semantic queries
        const interactiveRoles = ['button', 'link', 'tab', 'menuitem'];
        
        for (const role of interactiveRoles) {
          const elements = await page.getByRole(role).all();
          console.log(\`Found \${elements.length} \${role} elements\`);
          
          // Test up to 8 elements of each type
          for (let i = 0; i < Math.min(elements.length, 8); i++) {
            try {
              await safeElementInteraction(elements[i], 'click', { timeout: 3000 });
              await page.waitForTimeout(100); // Brief pause between interactions
            } catch (error) {
              console.log(\`⚠️  Could not interact with \${role} element \${i + 1}: \${error.message}\`);
            }
          }
        }
      });
    }
    
    // Report JavaScript errors
    if (consoleErrors.length > 0) {
      const errorReport = consoleErrors.map(error => 
        \`Page: \${error.url}\\nError: \${error.message}\${error.stack ? '\\nStack: ' + error.stack.substring(0, 200) + '...' : ''}\`
      ).join('\\n\\n');
      
      console.error(\`❌ Found \${consoleErrors.length} JavaScript errors\`);
      expect.soft(consoleErrors.length).toBe(0);
    } else {
      console.log('✅ No critical JavaScript errors detected');
    }`);
  }

  /**
   * Generate form test
   */
  generateFormTest() {
    return this.indent(`
    errorContext.setTest('Form Testing');
    
    if (!siteConfig.forms || siteConfig.forms.length === 0) {
      console.log('ℹ️  No forms configured for testing');
      return;
    }
    
    const testData = createTestData('contact');
    
    for (const formConfig of siteConfig.forms) {
      await test.step(\`Testing form: \${formConfig.name}\`, async () => {
        const formPage = formConfig.page || '/contact';
        errorContext.setPage(formPage);
        
        const response = await safeNavigate(page, \`\${siteConfig.baseUrl}\${formPage}\`);
        if (response.status() !== 200) {
          console.log(\`⚠️  Skipping form test for \${formPage} (status: \${response.status()})\`);
          return;
        }
        
        await waitForPageStability(page);
        
        // Find form using multiple strategies
        let form = null;
        const selectors = [formConfig.selector, '.wpcf7-form', '.contact-form', 'form'].filter(Boolean);
        
        for (const selector of selectors) {
          try {
            form = page.locator(selector).first();
            if (await form.isVisible()) break;
          } catch (error) {
            console.log(\`⚠️  Selector not found: \${selector}\`);
          }
        }
        
        if (!form || !(await form.isVisible())) {
          console.log(\`⚠️  No form found on \${formPage}\`);
          return;
        }
        
        // Test form fields using semantic queries first
        if (formConfig.fields) {
          // Name field
          if (formConfig.fields.name) {
            const nameField = page.getByLabel(/name/i).or(page.locator(formConfig.fields.name)).first();
            if (await nameField.isVisible()) {
              await safeElementInteraction(nameField, 'fill', { text: testData.formData.name });
            }
          }
          
          // Email field
          if (formConfig.fields.email) {
            const emailField = page.getByLabel(/email/i).or(page.locator(formConfig.fields.email)).first();
            if (await emailField.isVisible()) {
              await safeElementInteraction(emailField, 'fill', { text: testData.formData.email });
            }
          }
          
          // Message field
          if (formConfig.fields.message) {
            const messageField = page.getByLabel(/message/i).or(page.locator(formConfig.fields.message)).first();
            if (await messageField.isVisible()) {
              await safeElementInteraction(messageField, 'fill', { text: testData.formData.message });
            }
          }
        }
        
        console.log(\`✅ Form \${formConfig.name} fields filled successfully\`);
        // Note: We don't actually submit forms to avoid spam
      });
    }`);
  }

  /**
   * Generate accessibility test
   */
  generateAccessibilityTest() {
    return this.indent(`
    errorContext.setTest('Accessibility Testing');
    
    for (const testPage of siteConfig.testPages) {
      await test.step(\`Accessibility scan: \${testPage}\`, async () => {
        errorContext.setPage(testPage);
        
        const response = await safeNavigate(page, \`\${siteConfig.baseUrl}\${testPage}\`);
        if (response.status() !== 200) {
          console.log(\`⚠️  Skipping accessibility test for \${testPage} (status: \${response.status()})\`);
          return;
        }
        
        await waitForPageStability(page);
        
        try {
          const accessibilityScanResults = await new AxeBuilder({ page })
            .withTags(['wcag2a', 'wcag2aa', 'wcag21aa'])
            .analyze();
          
          const criticalViolations = accessibilityScanResults.violations.filter(
            violation => violation.impact === 'critical' || violation.impact === 'serious'
          );
          
          if (criticalViolations.length > 0) {
            const violationReport = criticalViolations.map(violation => 
              \`\${violation.id}: \${violation.description}\\nImpact: \${violation.impact}\\nHelp: \${violation.helpUrl}\\nNodes: \${violation.nodes.length}\`
            ).join('\\n\\n');
            
            console.error(\`❌ \${criticalViolations.length} critical accessibility violations on \${testPage}\`);
            expect.soft(criticalViolations.length).toBe(0);
          } else {
            console.log(\`✅ No critical accessibility violations on \${testPage}\`);
          }
          
          // Log moderate violations as warnings
          const moderateViolations = accessibilityScanResults.violations.filter(
            violation => violation.impact === 'moderate'
          );
          
          if (moderateViolations.length > 0) {
            console.log(\`⚠️  \${moderateViolations.length} moderate accessibility issues on \${testPage}\`);
          }
          
        } catch (error) {
          console.error(\`⚠️  Accessibility scan failed for \${testPage}: \${error.message}\`);
        }
      });
    }`);
  }

  /**
   * Generate critical elements test
   */
  generateCriticalElementsTest() {
    return this.indent(`
    errorContext.setTest('Critical Elements Check');
    
    for (const testPage of siteConfig.testPages) {
      await test.step(\`Checking critical elements: \${testPage}\`, async () => {
        errorContext.setPage(testPage);
        
        const response = await safeNavigate(page, \`\${siteConfig.baseUrl}\${testPage}\`);
        if (response.status() !== 200) {
          console.log(\`⚠️  Skipping critical elements test for \${testPage} (status: \${response.status()})\`);
          return;
        }
        
        await waitForPageStability(page);
        
        // Check for header
        const headerSelectors = ['header', '.header', '.site-header'];
        let headerFound = false;
        for (const selector of headerSelectors) {
          if (await page.locator(selector).isVisible()) {
            headerFound = true;
            break;
          }
        }
        expect.soft(headerFound, \`Header element should be present on \${testPage}\`).toBe(true);
        
        // Check for navigation
        const navSelectors = ['nav', '.main-navigation', '.primary-menu', '#main-menu'];
        let navFound = false;
        for (const selector of navSelectors) {
          if (await page.locator(selector).isVisible()) {
            navFound = true;
            break;
          }
        }
        expect.soft(navFound, \`Navigation element should be present on \${testPage}\`).toBe(true);
        
        // Check for footer
        const footerSelectors = ['footer', '.footer', '.site-footer'];
        let footerFound = false;
        for (const selector of footerSelectors) {
          if (await page.locator(selector).isVisible()) {
            footerFound = true;
            break;
          }
        }
        expect.soft(footerFound, \`Footer element should be present on \${testPage}\`).toBe(true);
        
        // Check for main content
        const mainSelectors = ['main', '.main', '.content', '#content'];
        let mainFound = false;
        for (const selector of mainSelectors) {
          if (await page.locator(selector).isVisible()) {
            mainFound = true;
            break;
          }
        }
        expect.soft(mainFound, \`Main content area should be present on \${testPage}\`).toBe(true);
        
        console.log(\`✅ Critical elements check completed for \${testPage}\`);
      });
    }`);
  }

  /**
   * Generate generic test based on test case configuration
   */
  generateGenericTest(testCase) {
    return this.indent(`
    errorContext.setTest('${testCase.name}');
    console.log('Running generic test: ${testCase.description}');
    
    // Placeholder for custom test implementation
    // This test case requires manual implementation based on specific requirements
    console.log('⚠️  Generic test case - manual implementation required');`);
  }

  /**
   * Utility methods
   */
  indent(code) {
    const spaces = ' '.repeat(this.indentLevel * this.indentSize);
    return spaces + code.trim();
  }

  formatCategoryTitle(category) {
    return category.split('-').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
  }

  formatSpecTitle(specName) {
    return specName.split('-').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
  }
}

module.exports = SpecificationToTestGenerator;
